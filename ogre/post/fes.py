#! /usr/bin/python
import copy,warnings,os
import numpy as np
from molmod.units import *

from ogre.input.utils import get_cv_units
import ogre.post.grid_utils as grid_utils

__all__ = ['generate_fes']


################################
# Free energy evaluation

# Generic free energy generator, which now uses the thermolib function below
# To alter the free energy calculation behaviour of the OGRe software, simply change the function call below
# to an appropriate free energy calculation function

def generate_fes(data, interactive=False, error_estimate=None, **params):
    # alter this line for custom FES calculation
    # if interactive: a tuple (grid, fes, fes_error) should be returned
    return generate_fes_thermolib(data,interactive=interactive,error_estimate=error_estimate,**params)

def get_executable(name):
    def is_tool(name):
        """Check whether `name` is on PATH and marked as executable."""

        # from whichcraft import which
        from shutil import which

        return which(name) is not None

    if is_tool(name):
        return name
    else:
        if os.path.exists('./'+name) and os.access('./'+name,os.X_OK):
            return './'+name
        else:
            raise IOError('There is no wham program available. Provide either a wham executable in the directory or have it available in the PATH.')


# An implementation for the evaluation of the free energy is provided below using ThermoLIB
# Similar functions can be created by the user based on this example

def generate_fes_thermolib(data,indices=None,interactive=False,index=None,error_estimate='mle_f',suffix=None):
        """
            Calculate and plot the free energy profile
            * Arguments 
                data            the data yml dictionary
                interactive     True if the data does not need to be stored to disk, but instead returned after function call
                index           integer, the max layer index to be taken into account
                error_estimate  the error estimate method from ThermoLIB
                suffix          suffix to append to all files generated by this function

        """
        import thermolib

        # Generate the required colvars and metadata file
        locations, trajs, kappas, identities, _ = grid_utils.load_grid(data,index,verbose=False)
        cv_units = get_cv_units(data)
        fes_unit = eval(data['fes_unit'])
        edges = { k:copy.copy(np.array(v)*cv_units) for k,v in data['edges'].items() }
        spacings = data['spacings'] * cv_units
        steps = data['HISTOGRAM_BIN_WIDTHS']
        temp = data['temp'] if 'temp' in data else 300.*kelvin

        # Adapt edges, extend range by at two spacings for sufficient leeway
        edges['max'] += spacings
        edges['min'] -= spacings

        if not 'temp' in data:
            warnings.warn('No temperature (temp) attribute was found in the data.yml file. Taking 300 K as a default value.')

        # Ravel the trajectories and grids
        rtrajs = np.zeros((0,*trajs[0][:,data['runup']:].shape[1:]))
        rlocations = np.zeros((0,*locations[0].shape[1:]))
        rkappas = np.zeros((0,*kappas[0].shape[1:]))
        ridentities = []
        for key in locations.keys():
            rtrajs = np.vstack((rtrajs,trajs[key][:,data['runup']:]))
            rlocations = np.vstack((rlocations,locations[key]))
            rkappas = np.vstack((rkappas,kappas[key]))
            ridentities += list(identities[key])

        #print("The full trajectories shape taken into account is: ", rtrajs.shape)
        # Account for possible indices
        if indices is not None:
            idx = np.array([i for i,id in enumerate(ridentities) if id in indices])
            #print(idx)
            rtrajs = rtrajs[idx]
            rkappas = rkappas[idx]
            rlocations = rlocations[idx]

        # Convert rlocations and rkappas to atomic units
        rkappas *= 1/cv_units**2 # energy unit remains fes_unit (since thermolib works with kjmol wham units for kappa, no conversion is performed)
        rlocations *= cv_units

        bins = [int(np.round((edges['max'][i]-edges['min'][i])/(steps[i]))) for i,_ in enumerate(edges['min'])]

        #WHAM analysis
        filename = 'metadata'
        if not index is None:
            filename += '_{}'.format(index)

        if not suffix is None:
            filename += '_{}'.format(suffix)

        grid_utils.write_colvars(filename,rtrajs,rlocations,rkappas,verbose=False)

        # Launch thermolib
        fes_err = np.array([np.nan,np.nan])
        bin_edges = [np.linspace(edges['min'][n],edges['max'][n],b+1) for n,b in enumerate(bins)]

        if len(steps) == 1:
            # 1D CASE
            _, biasses, trajectories = thermolib.read_wham_input(filename, path_template_colvar_fns='%s', stride=1, verbose=False)
            
            try:
                hist = thermolib.Histogram1D.from_wham_c(bin_edges[0], trajectories, biasses, temp, error_estimate=error_estimate,
                                        verbosity='none', convergence=1e-7, Nscf=100000)
            except FloatingPointError:
                error_estimate=None
                hist = thermolib.Histogram1D.from_wham_c(bin_edges[0], trajectories, biasses, temp, error_estimate=error_estimate,
                                        verbosity='none', convergence=1e-7, Nscf=100000)
                                        
            fes = thermolib.BaseFreeEnergyProfile.from_histogram(hist, temp)
            fes.set_ref(ref='min')
            grid = fes.cvs.copy().reshape(*bins,len(steps))
            fes_array = fes.fs.copy().reshape(*bins)

            if error_estimate is not None:
                if fes.flower is not None and fes.fupper is not None: 
                    fes_err = np.array([fes.flower.copy().reshape(*bins),fes.fupper.copy().reshape(*bins)])

        elif len(steps) == 2:
            # 2D CASE
            _, biasses, trajectories = thermolib.read_wham_input_2D(filename, path_template_colvar_fns='%s', stride=1, verbose=False)

            hist = thermolib.Histogram2D.from_wham_c(bin_edges, trajectories, biasses, temp, error_estimate=error_estimate,
                                        verbosity='none', convergence=1e-7, Nscf=10000, overflow_threshold=1e-150)

            fes = thermolib.FreeEnergySurface2D.from_histogram(hist, temp)
            fes.set_ref(ref='min')

            grid = np.array(np.meshgrid(fes.cv1s.copy(),fes.cv2s.copy())).T.reshape(*bins,len(steps))

            fes_array = fes.fs.copy().T.reshape(*bins)
            if error_estimate is not None:
                if fes.flower is not None and fes.fupper is not None: 
                    fes_err = np.array([fes.flower.copy().T.reshape(*bins),fes.fupper.copy().T.reshape(*bins)])
        else:
            raise NotImplementedError('Thermolib does not support N-dim free energy evaluation at this point.')
        
        # Remove the colvar and metadate files - (remove these lines for the final script)
        grid_utils.remove_colvars(filename)
        
        grid = grid/cv_units
        fes_array = fes_array/fes_unit
        fes_err = fes_err/fes_unit
        
        # If this function runs interactively, return the relevant parameters
        # otherwise save them to disk
        if interactive:
            grid_utils.write_fes(data,grid,fes_array,index,suffix=suffix,fes_err=fes_err)
            grid_utils.plot_fes(data,grid,fes_array,index,suffix=suffix,fes_err=fes_err)
            return grid,fes_array,fes_err
        else:
            grid_utils.write_fes(data,grid,fes_array,index,suffix=suffix,fes_err=fes_err)
            grid_utils.plot_fes(data,grid,fes_array,index,suffix=suffix,fes_err=fes_err)



def generate_fes_WHAM(data,indices=None,interactive=False,index=None,suffix=None,tol=0.00001,periodicity_x=0,periodicity_y=0):
    """
        Calculate and plot the free energy profile using the WHAM code of Grossfield
        * Arguments 
            data            the data yml dictionary
            interactive     True if the data does not need to be stored to disk, but instead returned after function call
            index           integer, the max layer index to be taken into account
            suffix          suffix to append to all files generated by this function
            tol             convergence tolerance for the WHAM calculations, Fi should not change by more than tol in every bin

    """
    import numpy.ma as ma
    warnings.warn('This method requires the wham and wham-2d scripts to be available in kjmol units (see header files of wham with #define k_B).')
    # Generate the required colvars and metadata file
    locations, trajs, kappas, identities, _ = grid_utils.load_grid(data,index,verbose=False)
    cv_units = get_cv_units(data)
    fes_unit = eval(data['fes_unit'])
    edges = { k:copy.copy(np.array(v)*cv_units) for k,v in data['edges'].items() }
    spacings = data['spacings'] * cv_units
    steps = data['HISTOGRAM_BIN_WIDTHS']
    temp = data['temp'] if 'temp' in data else 300.*kelvin
    
    # Adapt edges, extend range by at two spacings for sufficient leeway
    edges['max'] += spacings
    edges['min'] -= spacings

    if not 'temp' in data:
        warnings.warn('No temperature (temp) attribute was found in the data.yml file. Taking 300 K as a default value.')

    # Ravel the trajectories and grids
    rtrajs = np.zeros((0,*trajs[0][:,data['runup']:].shape[1:]))
    rlocations = np.zeros((0,*locations[0].shape[1:]))
    rkappas = np.zeros((0,*kappas[0].shape[1:]))
    ridentities = []
    for key in locations.keys():
        rtrajs = np.vstack((rtrajs,trajs[key][:,data['runup']:]))
        rlocations = np.vstack((rlocations,locations[key]))
        rkappas = np.vstack((rkappas,kappas[key]))
        ridentities += list(identities[key])

    # Account for possible indices
    if indices is not None:
        idx = np.array([i for i,id in enumerate(ridentities) if id in indices])
        #print(idx)
        rtrajs = rtrajs[idx]
        rkappas = rkappas[idx]
        rlocations = rlocations[idx]

    # Convert rlocations and rkappas to atomic units
    rkappas *= 1/cv_units**2 # energy unit remains fes_unit (since thermolib works with kjmol wham units for kappa, no conversion is performed)
    rlocations *= cv_units

    bins = [int(np.round((edges['max'][i]-edges['min'][i])/(steps[i]))) for i,_ in enumerate(edges['min'])]

    # WHAM analysis
    filename = 'metadata'
    outputname = 'free'
    if not index is None:
        filename += '_{}'.format(index)
        outputname += '_{}'.format(index)

    if not suffix is None:
        filename += '_{}'.format(suffix)
        outputname += '_{}'.format(suffix)

    grid_utils.write_colvars(filename,rtrajs,rlocations,rkappas,verbose=False)

    # Find executable
    if rtrajs.shape[-1] == 1:
        exec = get_executable('wham')
        command = exec + ' {} {} {} {} {} 0 {} {} > fes.log'.format(edges['min'][0], edges['max'][0], bins[0], tol, temp, filename, outputname)
    elif rtrajs.shape[-1] == 2:
        exec = get_executable('wham-2d')
        # ./wham-2d min_x max_x bins_x min_y max_y bins_y tolerance temp numpad metadataFile freeEnergyFile use_mask
        command = exec + ' Px={} {} {} {} Py={} {} {} {} {} {} 0 {} {} 1 > fes.log'.format(periodicity_x, edges['min'][0], edges['max'][0], bins[0],
         periodicity_y, edges['min'][1], edges['max'][1], bins[1], tol, temp, filename, outputname)
        # use_mask will not take into account bins for which there is no data
    else:
        raise NotImplementedError('WHAM has not yet been implemented for more than 2 dimensions.')

    os.system(command)
    if not os.path.exists(outputname):
        raise ValueError('The free energy profile could not be created using the following command: '+ command + '\n Try with other parameters!')

    # Load FES analysis
    if rtrajs.shape[-1] == 1:
        free = np.genfromtxt(outputname,usecols=(0,1))
    if rtrajs.shape[-1] == 2:
        free = np.genfromtxt(outputname,usecols=(0,1,2))

    free = free.reshape(*bins,rtrajs.shape[-1]+1) # one extra dimension for free energy
    fes = free[...,-1]
    grid = free[...,:-1]/cv_units
    fes[(fes==np.inf)|(fes==9999999.000000)] = ma.masked

    # If this function runs interactively, return the relevant parameters
    # otherwise save them to disk
    if interactive:
        grid_utils.write_fes(data,grid,fes,index,suffix=suffix)
        grid_utils.plot_fes(data,grid,fes,index,suffix=suffix)
        return grid,fes,np.array([np.nan,np.nan])
    else:
        grid_utils.write_fes(data,grid,fes,index,suffix=suffix)
        grid_utils.plot_fes(data,grid,fes,index,suffix=suffix)