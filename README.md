![ogre](./docs/ogre_icon_light_wide_path.svg#gh-light-mode-only)
![ogre](./docs/ogre_icon_dark_wide_path.svg#gh-dark-mode-only)


# OGRe-Yaff
OGRe-Yaff or "Optimal Grid Refinement tool" is a tool to minimize the computational effort for free energy evaluation methods that require an overlap of simulated probability densities. It is a package for an easy and automatic generation of a grid to perform umbrella sampling simulations with Yaff, and process the simulations on that grid to refine the grid parameters. In this way a converged free energy profile can be obtained.

OGRe is distributed as open source software under the conditions of the GPL license version 3. Read the file COPYING for more details, or visit http://www.gnu.org/licenses/

## INSTALLATION
OGRe-Yaff requires the following packages to work:
- cython, numpy, scipy,  h5py, matplotlib, yaml
- molmod
- yaff
- ThermoLIB


## INPUT
You can easily generate an initial uniform grid file for your system through the provided `ogre_input.py` script. Through specification of the kappa value for each of your CVs, the spacings between the initial grid points for each CV, and the boundaries for each CV, the `grid00.txt` is generated. This constitutes the first layer of your grid. This is copied to the `run.txt` file, containing all information for your first iteration of simulations. Aside from these CV parameters, additional hyperparameters have to be provided for the post processing, determining which points to refine, how to refine them, and the maximum number of layers. These should also be parsed as arguments to the input script, but can be tweaked later in the `data.yml` file that is generated by running the input script.

**Mode**

`analytic` \
intended to simulate analytic potentials for testing purposes

`application` \
intended to simulate actual Yaff force field simulations

**Simulation parameters**

`kappas` *[floats, comma separated list]* \
the umbrella constants for each CV in units of fes_unit/cv_units**2

`spacings` *[floats, comma separated list]* \
the initial cv spacings of the first layer in cv_units

`edges` *[floats, comma separated list]* \
the minimum and maximum values for the cvs in cv_units, *i.e.  `--edges min_cv_1,max_cv_1,min_cv_2,max_cv_2 ...`*

**-optional-**

`mdsteps` *[integer]* \
[default = 10000] number of md steps to execute

`runup` *[integer]* \
[default = 0] number of md steps to omit as equilibration time

`h5steps` *[integer]* \
[default = 5] saves the trajectory data every `h5steps` steps

`timestep` *[float]* \
[default = 0.5*fs] time step for the MD integrator (in atomic units)

`temp` *[float]* \
[default = 300.0*K] temperature for the MD simulation (in atomic units)

`timecon_thermo` *[float]* \
[default = 100.0*fs] timeconstant for the thermostat (in atomic units)

`press` *[float]* \
[default = 1e5*Pa] pressure for the MD simulation (in atomic units)

`timecon_baro` *[float]* \
[default = 1000.0*fs] timeconstant of the barostat (in atomic units)

`cv_units` *[strings, comma separated list]* \
[default = 1] the units in which you specify your collective variables, with respect to the units from your MD code following the molmod unit conventions\
*e.g.* for an MD code that uses atomic units, you can simply use the name of the unit you want for your cv(s), `--cv_units angstrom`

`fes_unit` *[string]* \
[default = kjmol] unit to express energies, with respect to the units from your MD and FES code following the molmod unit conventions

**Hyperparameters**

`CONFINEMENT_THR` *[float]* \
[default = 0.3] minimal percentage of the simulation that should be contained in the hypervolume defined by all the surrounding grid points to be considered as non-deviating

`OVERLAP_THR` *[float]* \
[default = 0.3] minimal percentage for the overlap of the histograms of two neighbouring trajectories

`KAPPA_GROWTH_FACTOR` *[float]* \
[default = 2] factor by which the kappa value is multiplied if the trajectory is deviating

`MAX_LAYERS` *[integer]* \
[default = 1] maximum number of grid layers that will be generated by the program, this in turn defines the minimal step size for each CV

`MAX_KAPPA` *[float]* \
[default = None] maximum value for kappa, if the protocol would attempt to increase the kappa value for a deviating simulation above this value, the free energy for this region is simply considered too high, and further refinement of this region is halted

`HISTOGRAM_BIN_WIDTHS` *[float]* \
[default = `spacings`/`MAX_LAYERS`/2] the bin width used in calculating the overlap integral

Should the final refinement not be sufficient, the `MAX_LAYERS` can always be adapted at a later stage in the `data.yml` file. It is however important to keep the `HISTOGRAM_BIN_WIDTHS` constant to avoid inconsistent overlap analyses.

**Example usage**

`ogre_input.py analytic --kappas 1.0,5.0 --spacings 0.5,0.5 --edges -10.0,10.0,0.0,5.0 --CONFINEMENT_THR 0.25 --OVERLAP_THR 0.25 --KAPPA_GROWTH_FACTOR 2 --MAX_LAYERS 2`

## SIMULATION
To perform the simulations you can use the ogre_sim.py script (or use the OGRe_Simulation class in your own code). This script takes the simulation identifiers as input arguments, and loads all other settings from the generated data.yml file. Ideally this script is executed in parallel over all required grid points of the `run.txt` file. An instructive example (using the OGRe_Simulation class instead of the script) is provided (on github), which simulates all required points for a simple analytic potential. This finally results in a folder `trajs`, containing all MD trajectories spawned by OGRe_Simulation, identified by their identifier (*e.g.* `trajs/traj_0_0.h5`). The required information for the post-processing step is obviously included in these trajectory files. 

**Analytic**
When performing analytic simulations, you are required to provide a `potential.py` file, specifying the energy behaviour as a function of the degrees of freedom (which coincide with the collective variables). This then obviously allows to calculate the exact profile as well to compare with later (see github for an example). (***Note***) The MD pressure arguments are neglected for these simulation, and the temperature is controlled with a CVSR thermostat.

**Application**
When performing actual force field simulations with Yaff, you are required to provide a system file named `init.chk` containing all the relevant information as for any Yaff simulation. Moreover, all `pars*.txt` files are loaded as the force field parameters. Finally, a `custom_cv.py` file is required which specifies the collective variable in a Yaff format (see github for example). (***Note***) The specific force field settings for ff.generate() should be adapted in the `sim/core.py` script manually.

**Example usage**

`ogre_sim.py --grid 0 --nr 0 --cvs 0.0,0.5 --kappas 10.0,10.0`

## POSTPROCESSING
For the evaluation of your collection of simulations, you can use the ogre_post.py script. This can evaluate the quality of each simulation by considering their deviation from the umbrella center and the overlap with simulations of neighbouring grid points. After this evaluation, it will refine the kappa values of existing grid files for deviating simulations, and generate additional grid points in regions where the overlap was insufficient.

`ogre_post.py --overlap` \
`ogre_post.py --fes`

You can add the `--test` flag when performing the overlap analysis to avoid creating, deleting, or replacing certain files or file entries. This can be convenient when tweaking the hyperparameters.
