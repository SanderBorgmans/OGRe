![ogre](./docs/ogre_icon_light_wide_path.svg#gh-light-mode-only)
![ogre](./docs/ogre_icon_dark_wide_path.svg#gh-dark-mode-only)


# OGRe-Simulator
OGRe-Simulator or "Optimal Grid Refinement tool" is a tool to minimize the computational effort for free energy evaluation methods that require an overlap of simulated probability densities. It is a package for an easy and automatic generation of a grid to perform umbrella sampling simulations with a custom simulator, and process the simulations on that grid to refine the grid parameters. In this way a converged free energy profile can be obtained.

OGRe is distributed as open source software under the conditions of the GPL license version 3. Read the file COPYING for more details, or visit http://www.gnu.org/licenses/

## INSTALLATION
OGRe-Simulator requires the following packages to work:
- cython, numpy, scipy,  h5py, matplotlib, yaml
- molmod
- ThermoLIB


## INPUT
You can easily generate the initial layer file for your system through the provided `ogre_input.py` script. Through specification of the kappa value for each of your CVs, the spacings between the initial grid points for each CV, and the boundaries for each CV, the `layer00.txt` is generated. This constitutes the first layer of your grid. This is copied to the `run.txt` file, containing all information for your first iteration of simulations. Aside from these CV parameters, additional hyperparameters have to be provided for the post processing, determining which points to refine, how to refine them, and the maximum number of layers. These should also be parsed as arguments to the input script, but can be tweaked later in the `data.yml` file that is generated by running the input script.

**Simulation parameters**

`kappas` *[floats, comma separated list]* \
the umbrella constants for each CV in units of fes_unit/cv_units**2

`spacings` *[floats, comma separated list]* \
the initial cv spacings of the first layer in cv_units

`edges` *[floats, comma separated list]* \
the minimum and maximum values for the cvs in cv_units, *i.e.  `--edges min_cv_1,max_cv_1,min_cv_2,max_cv_2 ...`*

**-optional-**

`cv_units` *[strings, comma separated list]* \
[default = 1] the units in which you specify your collective variables, with respect to the units from your MD code following the molmod unit conventions\
*e.g.* for an MD code that uses atomic units, you can simply use the name of the unit you want for your cv(s), `--cv_units angstrom`

`fes_unit` *[string]* \
[default = kjmol] unit to express energies, with respect to the units from your MD and FES code following the molmod unit conventions

Other MD parameters can be defined in a `--key value` manner.

**Hyperparameters**

`CONFINEMENT_THR` *[float]* \
[default = 0.3] minimal percentage of the simulation that should be contained in the hypervolume defined by all the surrounding grid points to be considered as non-deviating

`OVERLAP_THR` *[float]* \
[default = 0.3] minimal percentage for the overlap of the histograms of two neighbouring trajectories

`KAPPA_GROWTH_FACTOR` *[float]* \
[default = 2] factor by which the kappa value is multiplied if the trajectory is deviating

`MAX_LAYERS` *[integer]* \
[default = 1] maximum number of grid layers that will be generated by the program, this in turn defines the minimal step size for each CV

`MAX_KAPPA` *[float]* \
[default = None] maximum value for kappa, if the protocol would attempt to increase the kappa value for a deviating simulation above this value, the free energy for this region is simply considered too high, and further refinement of this region is halted

`HISTOGRAM_BIN_WIDTHS` *[float]* \
[default = `spacings`/`MAX_LAYERS`/2] the bin width used in calculating the overlap integral

Should the final refinement not be sufficient, the `MAX_LAYERS` can always be adapted at a later stage in the `data.yml` file. It is however important to keep the `HISTOGRAM_BIN_WIDTHS` constant to avoid inconsistent overlap analyses.

**Example usage**

`ogre_input.py analytic --kappas 1.0,5.0 --spacings 0.5,0.5 --edges -10.0,10.0,0.0,5.0 --CONFINEMENT_THR 0.25 --OVERLAP_THR 0.25 --KAPPA_GROWTH_FACTOR 2 --MAX_LAYERS 2`

## SIMULATION
To perform the simulations you can use the ogre_sim.py script (or use the OGRe_Simulation class in your own code). This script takes the simulation identifiers as input arguments, and loads all other settings from the generated data.yml file. Ideally this script is executed in parallel over all required grid points of the `run.txt` file. An instructive example (using the OGRe_Simulation class instead of the script) is provided (on github), which simulates all required points for a simple analytic potential. This finally results in a folder `trajs`, containing all MD trajectories spawned by OGRe_Simulation, identified by their identifier (*e.g.* `trajs/traj_0_0.h5`). The required information for the post-processing step is obviously included in these trajectory files. 

**Example usage**

`ogre_sim.py --layer 0 --nr 0`

## POSTPROCESSING
For the evaluation of your collection of simulations, you can use the ogre_post.py script. This can evaluate the quality of each simulation by considering their deviation from the umbrella center and the overlap with simulations of neighbouring grid points. After this evaluation, it will refine the kappa values of existing grid files for deviating simulations, and generate additional grid points in regions where the overlap was insufficient.

`ogre_post.py --overlap` \
`ogre_post.py --fes`

You can add the `--debug` flag when performing the overlap analysis to avoid creating, deleting, or replacing certain files or file entries. This can be convenient when tweaking the hyperparameters.
